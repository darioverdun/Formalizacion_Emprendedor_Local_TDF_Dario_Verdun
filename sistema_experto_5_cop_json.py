# -*- coding: utf-8 -*-
"""Sistema_Experto_5_jason.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1heuWvyNavGGn7sPpWxfVUrStBMvaW6YM
"""

import json # Importamos la librería json para trabajar con los archivos
import os # Necesario para verificar si los archivos existen
import pandas as pd # <-- Nuevo: Importamos la librería pandas

def limpiar_valor(texto):
    """
    Limpia un string de valor monetario (ej: '$ 7.813.063,45'),
    de superficie ('Hasta 30 m2') o energía ('Hasta 3330 Kw') a float.
    Retorna None si no se puede convertir.
    """
    if pd.isna(texto): # Maneja valores NaN (vacíos) de pandas
        return None
    
    s_valor = str(texto)
    # Eliminar '$', 'Hasta ', ' m2', ' Kw', puntos de miles y espacios
    s_valor = s_valor.replace('$', '').replace('.', '').replace('Hasta ', '').replace(' m2', '').replace(' Kw', '').strip()
    # Reemplazar coma por punto decimal
    s_valor = s_valor.replace(',', '.')
    
    try:
        return float(s_valor)
    except ValueError:
        return None # Retorna None si no se puede convertir (ej. si era una celda vacía o texto inesperado)


def obtener_datos_monotributo_web():
    """
    Intenta obtener los datos de Monotributo de la web usando pandas.
    Devuelve las estructuras de datos si tiene éxito, de lo contrario None, None.
    """
    url = "https://www.afip.gob.ar/monotributo/categorias.asp"
    categorias_dict = {"servicios": {}, "venta": {}}
    pagos_dict = {"servicios": {}, "venta": {}}

    print(f"Intentando obtener datos de Monotributo de la web: {url}...")
    try:
        # Usar pandas para leer todas las tablas de la página
        tablas = pd.read_html(url)
        
        df_monotributo = None
        # Buscar la tabla correcta: aquella que contenga una columna 'Categ.' o donde la primera columna sea 'Categ.'
        # y que contenga la categoría 'K'.
        for tabla in tablas:
            # Algunas tablas pueden tener encabezados multilinea o complejos,
            # lo que puede hacer que 'Categ.' no sea el nombre exacto de la columna 0.
            # Comprobamos si 'Categ.' está en las columnas o en la primera columna (iloc[0])
            # La condición ahora busca 'Categ.' en la primera parte de la tupla del encabezado si es multi-nivel
            if (len(tabla.columns) > 0 and 
                (tabla.columns[0] == 'Categ.' or 
                 (isinstance(tabla.columns[0], tuple) and 'Categ.' in tabla.columns[0][0]))): # Ajuste aquí para tupla
                
                # Intentar ver si la categoría 'K' está en la primera columna (asumiendo que es la de categorías)
                if 'K' in tabla.iloc[:, 0].astype(str).values: # Convertir a str para asegurar comparación
                    df_monotributo = tabla
                    break
        
        if df_monotributo is None:
            print(f"Error: No se encontró la tabla de categorías del Monotributo en {url}.")
            return None, None
        
        # --- LÍNEA DE DEPURACIÓN TEMPORAL (Mantener para verificar) ---
        print("\n--- Estructura del DataFrame encontrado por Pandas ---")
        print("Columnas del DataFrame (original):", df_monotributo.columns.tolist())
        print("Primeras 5 filas del DataFrame (original):\n", df_monotributo.head())
        print("--- Fin de la estructura del DataFrame (original) ---\n")
        # --- FIN LÍNEA DE DEPURACIÓN ---

        # --- INICIO DE LA CORRECCIÓN DE COLUMNAS ---
        # Si las columnas son tuplas (multi-nivel), aplanarlas a nombres más simples
        nuevas_columnas = []
        for col in df_monotributo.columns:
            if isinstance(col, tuple):
                # Unir los elementos de la tupla para formar un nombre de columna único y legible
                # Ej: ('Impuesto integrado', 'Locaciones y prestaciones de servicios') -> 'Impuesto integrado_Locaciones y prestaciones de servicios'
                # o si el primer elemento es el mismo que el segundo, usar solo el segundo para ser más conciso
                if col[0] == col[1]:
                    nuevas_columnas.append(col[0].replace(' (*)', '').replace(' (**)', '').replace(' (***)', '').replace(' (****)', '').strip())
                elif col[0] == 'Impuesto integrado' and col[1] == 'Locaciones y prestaciones de servicios':
                    nuevas_columnas.append('Impuesto integrado Servicios')
                elif col[0] == 'Impuesto integrado' and col[1] == 'Venta de cosas muebles':
                    nuevas_columnas.append('Impuesto integrado Venta')
                elif col[0] == 'Total' and col[1] == 'Locaciones y prestaciones de servicios':
                    nuevas_columnas.append('Total Servicios')
                elif col[0] == 'Total' and col[1] == 'Venta de cosas muebles':
                    nuevas_columnas.append('Total Venta')
                else: # Fallback para otros multi-encabezados inesperados
                    nuevas_columnas.append('_'.join(map(str, col)).replace(' (*)', '').replace(' (**)', '').replace(' (***)', '').replace(' (****)', '').strip())
            else:
                # Si la columna no es una tupla, úsala tal cual (limpiando posibles notas)
                nuevas_columnas.append(col.replace(' (*)', '').replace(' (**)', '').replace(' (***)', '').replace(' (****)', '').strip())
        
        df_monotributo.columns = nuevas_columnas

        # Ahora que los encabezados son simples, podemos acceder por nombre
        # También verificamos si el DataFrame tiene un encabezado doble de Pandas (fila 0 duplicada)
        # Esto sucede cuando la primera fila de datos es idéntica al header procesado
        # Podemos eliminarla si la primera columna de la primera fila de datos es igual al nombre de la primera columna
        if df_monotributo.iloc[0, 0] == df_monotributo.columns[0]:
            df_monotributo = df_monotributo.iloc[1:].copy() # Saltar la primera fila si es un duplicado de encabezado

        # Eliminar filas de encabezado repetidas o pies de tabla que pandas podría haber incluido
        # Filtra solo las filas donde la primera columna (Categoría) es una letra simple (A-K)
        df_monotributo = df_monotributo[df_monotributo['Categ.'].astype(str).str.fullmatch(r'[A-K]', na=False)]
        
        # --- LÍNEA DE DEPURACIÓN TEMPORAL (VERIFICAR TRAS LIMPIEZA) ---
        print("\n--- Estructura del DataFrame DESPUÉS de la limpieza de columnas y filas ---")
        print("Columnas del DataFrame:", df_monotributo.columns.tolist())
        print("Primeras 5 filas del DataFrame:\n", df_monotributo.head())
        print("--- Fin de la estructura del DataFrame (limpio) ---\n")
        # --- FIN LÍNEA DE DEPURACIÓN ---
        # --- FIN DE LA CORRECCIÓN DE COLUMNAS ---

        # Iterar sobre las filas del DataFrame para llenar los diccionarios JSON
        # Ahora accedemos por nombre de columna, que es más legible y robusto
        for index, row in df_monotributo.iterrows():
            categoria_letra = row['Categ.'] # Acceso por nombre de columna
            
            # Datos para categorias.json
            ingresos_servicios_web = limpiar_valor(row['Ingresos brutos'])
            ingresos_venta_web = limpiar_valor(row.get('Ingresos brutos (*)', None))
            superficie_web = limpiar_valor(row['Sup. Afectada'])
            energia_web = limpiar_valor(row['Energía eléctrica consumida anualmente'])
            alquileres_web = limpiar_valor(row['Alquileres devengados anualmente'])
            # Obtener el precio unitario máximo para venta de cosas muebles
            precio_unitario_maximo_web = limpiar_valor(row.get('Precio unitario máximo para venta de cosas muebles', 466361.15))

            categorias_dict["servicios"][categoria_letra] = {
                "ingresos": ingresos_servicios_web,
                "superficie": superficie_web,
                "energia": energia_web,
                "alquileres": alquileres_web
            }
            # Para la categoría de venta, si los ingresos no están en la columna de venta, usa los de servicios
            categorias_dict["venta"][categoria_letra] = {
                "ingresos": ingresos_venta_web if ingresos_venta_web is not None else ingresos_servicios_web,
                "superficie": superficie_web,
                "energia": energia_web,
                "alquileres": alquileres_web,
                "precio_unitario_maximo": precio_unitario_maximo_web
            }

            # Datos para pagos.json
            solo_impuesto_servicios_web = limpiar_valor(row['Impuesto integrado Servicios']) # Acceso por nombre
            solo_impuesto_venta_web = limpiar_valor(row['Impuesto integrado Venta']) # Acceso por nombre
            sipa_web = limpiar_valor(row['Aportes al SIPA']) # Acceso por nombre
            obra_social_web = limpiar_valor(row['Aportes obra social']) # Acceso por nombre
            completo_servicios_web = limpiar_valor(row['Total Servicios']) # Acceso por nombre
            completo_venta_web = limpiar_valor(row['Total Venta']) # Acceso por nombre

            pagos_dict["servicios"][categoria_letra] = {
                "solo_impuesto": solo_impuesto_servicios_web,
                "completo": completo_servicios_web,
                "sipa": sipa_web,
                "obra_social": obra_social_web
            }
            pagos_dict["venta"][categoria_letra] = {
                "solo_impuesto": solo_impuesto_venta_web,
                "completo": completo_venta_web,
                "sipa": sipa_web,
                "obra_social": obra_social_web
            }

        print("Datos de Monotributo obtenidos exitosamente de la web con pandas.")
        return categorias_dict, pagos_dict

    except Exception as e:
        print(f"Ocurrió un error al obtener datos de la web con pandas: {e}")
        return None, None

def guardar_datos_json_locales(categorias, pagos):
    """Guarda los datos de categorías y pagos en archivos JSON locales."""
    try:
        with open('categorias.json', 'w', encoding='utf-8') as f:
            json.dump(categorias, f, indent=4, ensure_ascii=False)
        with open('pagos.json', 'w', encoding='utf-8') as f:
            json.dump(pagos, f, indent=4, ensure_ascii=False)
        print("Datos guardados localmente en 'categorias.json' y 'pagos.json'.")
    except Exception as e:
        print(f"Error al guardar datos localmente: {e}")

def cargar_datos_json_locales():
    """Carga los datos de categorías y pagos desde archivos JSON locales."""
    categorias = {}
    pagos = {}
    try:
        if os.path.exists('categorias.json') and os.path.exists('pagos.json'):
            with open('categorias.json', 'r', encoding='utf-8') as f:
                categorias = json.load(f)
            with open('pagos.json', 'r', encoding='utf-8') as f:
                pagos = json.load(f)
            print("Datos de categorías y pagos cargados desde archivos locales.")
        else:
            print("No se encontraron archivos JSON locales. Se crearán si el scraping es exitoso o se usará data por defecto.")
            return None, None
    except json.JSONDecodeError as e:
        print(f"Error al decodificar JSON localmente. Los archivos pueden estar corruptos: {e}")
        return None, None
    except Exception as e:
        print(f"Error al cargar datos locales: {e}")
        return None, None
    return categorias, pagos

# --- BLOQUE DE ACTUALIZACIÓN DE DATOS (COLOCAR AL INICIO DEL SCRIPT) ---
print("--- INICIO DEL PROCESO DE ACTUALIZACIÓN DE DATOS ---")
datos_categorias_actualizados = None
datos_pagos_actualizados = None

# 1. Intentar obtener datos de la web
datos_categorias_web, datos_pagos_web = obtener_datos_monotributo_web()

if datos_categorias_web and datos_pagos_web:
    print("Datos de la web obtenidos correctamente. Guardando y utilizando estos datos.")
    datos_categorias_actualizados = datos_categorias_web
    datos_pagos_actualizados = datos_pagos_web
    guardar_datos_json_locales(datos_categorias_actualizados, datos_pagos_actualizados)
else:
    print("No se pudieron obtener datos actualizados de la web. Intentando cargar datos locales existentes...")
    # 2. Si falla la web, intentar cargar desde local
    datos_categorias_locales, datos_pagos_locales = cargar_datos_json_locales()
    if datos_categorias_locales and datos_pagos_locales:
        print("Datos locales cargados con éxito.")
        datos_categorias_actualizados = datos_categorias_locales
        datos_pagos_actualizados = datos_pagos_locales
    else:
        print("No se pudieron cargar datos locales. El programa podría no funcionar correctamente sin datos de Monotributo.")
        datos_categorias_actualizados = {"servicios": {}, "venta": {}}
        datos_pagos_actualizados = {"servicios": {}, "venta": {}}

print("--- FIN DEL PROCESO DE ACTUALIZACIÓN DE DATOS ---")
# --- FIN DEL BLOQUE DE ACTUALIZACIÓN DE DATOS ---

# A partir de aquí continuaría el resto de tu sistema experto,
# utilizando 'datos_categorias_actualizados' y 'datos_pagos_actualizados'
# como tus fuentes de datos para las categorías y pagos.

def preguntar(pregunta, opciones):
    """
    Realiza una pregunta al usuario y valida la respuesta.
    """
    while True:
        print(f"\n--- {pregunta} ---")
        for i, opcion in enumerate(opciones):
            print(f"{i + 1}. {opcion}")
        respuesta = input("Tu respuesta (número): ").strip()
        if respuesta.isdigit() and 1 <= int(respuesta) <= len(opciones):
            return opciones[int(respuesta) - 1]
        else:
            print("Respuesta inválida. Por favor, ingresa el número de la opción deseada.")

def mostrar_resultado(resultado):
    """
    Muestra el resultado final.
    """
    print("\n" + "="*50)
    print(f"RESULTADO: {resultado}")
    print("="*50)

def obtener_valor_numerico(pregunta):
    """
    Solicita al usuario un valor numérico y permite dejarlo en blanco.
    Si se deja en blanco, devuelve None.
    """
    while True:
        respuesta = input(f"\n{pregunta} (Deja en blanco si no lo sabes o no aplica): ").strip()
        if respuesta == "":
            return None
        try:
            return float(respuesta)
        except ValueError:
            print("Entrada inválida. Por favor, ingresa un número o deja en blanco.")

def cargar_datos_monotributo():
    """
    Carga los datos de categorías y pagos desde archivos JSON.
    Esta función ahora usará los datos que se actualizaron globalmente.
    """
    # En lugar de leer de archivos, esta función ahora devuelve los datos
    # que fueron cargados o scrapeados al inicio del script.
    if datos_categorias_actualizados and datos_pagos_actualizados:
        return datos_categorias_actualizados, datos_pagos_actualizados
    else:
        # Esto solo se ejecutaría si el proceso de actualización inicial falló completamente
        print("\n--- ERROR ---")
        print("¡Advertencia! No se pudieron obtener datos de Monotributo para cargar.")
        print("El programa no puede funcionar sin estos datos.")
        print("--- FIN ERROR ---")
        exit()


def sistema_experto_monotributo():
    """
    Implementación del sistema experto para determinar la categoría de Monotributo.
    """
    print("Bienvenido al Asistente de Monotributo.")
    print("Te guiaré a través de una serie de preguntas para determinar tu situación fiscal.")

    # --- Cargar los datos al inicio del sistema experto ---
    # Esta llamada ahora utilizará las variables globales actualizadas
    datos_cargados, pagos_cargados = cargar_datos_monotributo()
    categorias_servicios = datos_cargados['servicios']
    categorias_venta = datos_cargados['venta']
    pagos_monotributo_servicios = pagos_cargados['servicios']
    pagos_monotributo_venta = pagos_cargados['venta']
    # ----------------------------------------------------

    # Pregunta inicial: Persona Jurídica
    res_persona_juridica = preguntar(
        "¿Sos persona jurídica (empresa o sociedad)?",
        ["SÍ", "NO (Persona Física)"]
    )

    if res_persona_juridica == "SÍ":
        mostrar_resultado("Régimen General (No calificás para Monotributo)")
        return

    # NUEVA PREGUNTA: ¿Perteneces a alguna sociedad?
    res_socio_sociedad = preguntar(
        "¿Sos socio o parte de alguna sociedad?",
        ["SÍ", "NO"]
    )

    if res_socio_sociedad == "SÍ":
        mostrar_resultado("Régimen General (Los socios de sociedades no pueden ser Monotributistas)")
        return

    # Si es persona física y no es socio de sociedad, continúa con el flujo normal
    res_actividades_diferentes = preguntar(
        "¿Vas a realizar más de 3 actividades económicas diferentes?",
        ["SÍ", "NO (3 o menos actividades)"]
    )

    if res_actividades_diferentes == "SÍ":
        mostrar_resultado("Régimen General (Más de 3 actividades)")
        return

    # 3 o menos actividades
    res_actividad_servicios = preguntar(
        "¿Tu actividad principal es la prestación de servicios?",
        ["SÍ (Prestación de Servicios)", "NO (Venta de Cosas Muebles)"]
    )

    if res_actividad_servicios == "SÍ":
        # --- Rama: Prestación de Servicios ---
        res_generas_ingresos_servicios = preguntar(
            "¿Ya estás generando ingresos y podés estimar tu facturación anual?",
            ["SÍ", "NO"]
        )

        if res_generas_ingresos_servicios == "SÍ":
            # Si responde SÍ, ahora sí pedimos el valor numérico
            ingresos_anuales = obtener_valor_numerico("Ingresá tu proyección de ingresos brutos anuales (ej: 5000000.00):")

            if ingresos_anuales is not None and ingresos_anuales > categorias_servicios['H']['ingresos']:
                mostrar_resultado("Régimen General (Excede límite de ingresos para servicios)")
                return

            res_tiene_local_servicios = preguntar(
                "¿Tu actividad se desarrolla en un local o establecimiento físico (alquilado o propio)?",
                ["SÍ (Tiene local)", "NO (No tiene local)"]
            )

            if res_tiene_local_servicios == "SÍ (Tiene local)":
                categoria_final = None
                # Ordenar las categorías para iterar de A a H
                categorias_ordenadas = sorted(categorias_servicios.keys())

                for cat_letra in categorias_ordenadas:
                    limites = categorias_servicios[cat_letra]

                    # Regla de ingresos (siempre se valida, si ya se pasó el límite global, se salió antes)
                    if ingresos_anuales is not None and ingresos_anuales > limites['ingresos']:
                        continue # Pasa a la siguiente categoría

                    # Pregunta de Superficie
                    res_superficie = preguntar(
                        f"¿La superficie afectada de tu local **supera** los **{limites['superficie']} m2** para la Categoría {cat_letra}?",
                        ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                    )
                    if res_superficie == "SÍ (Supera el límite)":
                        continue # Correcto: pasa a la siguiente categoría

                    # Pregunta de Energía
                    res_energia = preguntar(
                        f"¿El consumo anual de energía eléctrica de tu local **supera** los **{limites['energia']} Kw** para la Categoría {cat_letra}?",
                        ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                    )
                    if res_energia == "SÍ (Supera el límite)":
                        continue # Correcto: pasa a la siguiente categoría

                    # Pregunta de Alquileres
                    res_alquileres = preguntar(
                        f"¿Los alquileres devengados anualmente de tu local **superan** los **${limites['alquileres']:,.2f}** para la Categoría {cat_letra}?",
                        ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                    )
                    if res_alquileres == "SÍ (Supera el límite)":
                        continue # Correcto: pasa a la siguiente categoría

                    # Si llega hasta aquí, significa que el usuario respondió 'NO' a todos los parámetros de esta categoría
                    categoria_final = cat_letra
                    break # Encontramos la categoría, salimos del bucle de categorías

                if categoria_final:
                    print(f"\nSegún tus ingresos y los parámetros del local, tu categoría sería la **{categoria_final}**.")
                    res_rel_dependencia = preguntar(
                        "¿Actualmente te encontrás en relación de dependencia?",
                        ["SÍ", "NO"]
                    )
                    if res_rel_dependencia == "SÍ":
                        mostrar_resultado(f"Monotributo Categoría {categoria_final} (Solo Impuesto Integrado: ${pagos_monotributo_servicios[categoria_final]['solo_impuesto']:,.2f})")
                    else:
                        mostrar_resultado(f"Monotributo Categoría {categoria_final} (Impuesto Integrado: ${pagos_monotributo_servicios[categoria_final]['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_servicios[categoria_final]['sipa']:,.2f}, Obra Social: ${pagos_monotributo_servicios[categoria_final]['obra_social']:,.2f}, Total: ${pagos_monotributo_servicios[categoria_final]['completo']:,.2f})")
                else:
                    mostrar_resultado("Régimen General (No encuadra en Monotributo por límites de local o ingresos, incluso para la categoría más baja).")

            else: # NO tiene local (Servicios)
                print("\nDebes evaluar tu categoría solo por límite de ingresos brutos.")
                categoria_encontrada = None
                for cat_letra, limites in categorias_servicios.items():
                    if ingresos_anuales is None or ingresos_anuales <= limites['ingresos']:
                        categoria_encontrada = cat_letra
                        break

                if categoria_encontrada:
                    print(f"\nSegún tus ingresos, tu categoría sería la **{categoria_encontrada}**.")
                    res_rel_dependencia = preguntar(
                        "¿Actualmente te encontrás en relación de dependencia?",
                        ["SÍ", "NO"]
                    )
                    if res_rel_dependencia == "SÍ":
                        mostrar_resultado(f"Monotributo Categoría {categoria_encontrada} (Solo Impuesto Integrado: ${pagos_monotributo_servicios[categoria_encontrada]['solo_impuesto']:,.2f})")
                    else:
                        mostrar_resultado(f"Monotributo Categoría {categoria_encontrada} (Impuesto Integrado: ${pagos_monotributo_servicios[categoria_encontrada]['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_servicios[categoria_encontrada]['sipa']:,.2f}, Obra Social: ${pagos_monotributo_servicios[categoria_encontrada]['obra_social']:,.2f}, Total: ${pagos_monotributo_servicios[categoria_encontrada]['completo']:,.2f})")
                else:
                    mostrar_resultado("Régimen General (No encuadra en Monotributo por ingresos)")

        else: # No genera ingresos / No puede estimar facturación anual (Servicios) - Categoría A Provisoria
            print("\nDado que no generás ingresos o no podés estimar tu facturación, se evaluará la **Categoría A Provisoria**.")
            res_tiene_local_prov_servicios = preguntar(
                "¿Tu actividad se desarrolla en un local físico (alquilado o propio)?",
                ["SÍ (Tiene local)", "NO (No tiene local)"]
            )

            if res_tiene_local_prov_servicios == "SÍ (Tiene local)":
                # Límites para Categoría A (que se usan para la inscripción provisoria)
                limites_cat_A_servicios = categorias_servicios['A']

                # Ahora con las preguntas que usan los límites de Categoría A
                res_superficie_prov = preguntar(
                    f"¿La superficie afectada de tu local **supera** los **{limites_cat_A_servicios['superficie']} m2** para la Categoría A?",
                    ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                )
                if res_superficie_prov == "SÍ (Supera el límite)":
                    mostrar_resultado("Régimen General (No encuadra Monotributo provisorio por límite de superficie para Categoría A)")
                    return # Aquí SÍ queremos que termine si la provisoria no cumple

                res_energia_prov = preguntar(
                    f"¿El consumo anual de energía eléctrica de tu local **supera** los **{limites_cat_A_servicios['energia']} Kw** para la Categoría A?",
                    ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                )
                if res_energia_prov == "SÍ (Supera el límite)":
                    mostrar_resultado("Régimen General (No encuadra Monotributo provisorio por límite de energía para Categoría A)")
                    return # Aquí SÍ queremos que termine si la provisoria no cumple

                res_alquileres_prov = preguntar(
                    f"¿Los alquileres devengados anualmente de tu local **superan** los **${limites_cat_A_servicios['alquileres']:,.2f}** para la Categoría A?",
                    ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                )
                if res_alquileres_prov == "SÍ (Supera el límite)":
                    mostrar_resultado("Régimen General (No encuadra Monotributo provisorio por límite de alquileres para Categoría A)")
                    return # Aquí SÍ queremos que termine si la provisoria no cumple

                # Si llega hasta aquí, cumple con Categoría A con local para inscripción provisoria
                print("\nCumplís con los límites de los parámetros del local para la Categoría A (inscripción provisoria).")
                res_rel_dep_prov = preguntar(
                    "¿Actualmente estás en relación de dependencia?",
                    ["SÍ", "NO"]
                )
                if res_rel_dep_prov == "SÍ":
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Solo Impuesto Integrado: ${pagos_monotributo_servicios['A']['solo_impuesto']:,.2f})")
                else:
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Impuesto Integrado: ${pagos_monotributo_servicios['A']['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_servicios['A']['sipa']:,.2f}, Obra Social: ${pagos_monotributo_servicios['A']['obra_social']:,.2f}, Total: ${pagos_monotributo_servicios['A']['completo']:,.2f})")
            else: # No tiene local (Servicios, A Provisoria)
                print("\nComo no generás ingresos y no tenés local, tu categoría provisoria es la **A**.")
                res_rel_dep_prov = preguntar(
                    "¿Actualmente estás en relación de dependencia?",
                    ["SÍ", "NO"]
                )
                if res_rel_dep_prov == "SÍ":
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Solo Impuesto Integrado: ${pagos_monotributo_servicios['A']['solo_impuesto']:,.2f})")
                else:
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Impuesto Integrado: ${pagos_monotributo_servicios['A']['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_servicios['A']['sipa']:,.2f}, Obra Social: ${pagos_monotributo_servicios['A']['obra_social']:,.2f}, Total: ${pagos_monotributo_servicios['A']['completo']:,.2f})")

    else: # Actividad principal es Venta de Cosas Muebles
        # --- Rama: Venta de Cosas Muebles ---
        res_precio_unitario = preguntar(
            "¿El precio unitario máximo de venta excede $466.361,15?",
            ["SÍ", "NO"]
        )

        if res_precio_unitario == "SÍ":
            mostrar_resultado("Régimen General (Excede límite de precio unitario)")
            return

        res_generas_ingresos_venta = preguntar(
            "¿Ya estás generando ingresos y podés estimar tu facturación anual?",
            ["SÍ", "NO"]
        )

        if res_generas_ingresos_venta == "SÍ":
            # Si responde SÍ, ahora sí pedimos el valor numérico
            ingresos_anuales = obtener_valor_numerico("Ingresá tu proyección de ingresos brutos anuales (ej: 5000000.00):")
            limite_max_monotributo = categorias_venta['K']['ingresos']

            if ingresos_anuales is not None and ingresos_anuales > limite_max_monotributo:
                mostrar_resultado("Régimen General (Excede límite de ingresos)")
                return

            res_tiene_local_venta = preguntar(
                "¿Tu actividad se desarrolla en un local o establecimiento físico (alquilado o propio)?",
                ["SÍ (Tiene local)", "NO (No tiene local)"]
            )

            if res_tiene_local_venta == "SÍ (Tiene local)":
                categoria_final = None
                # Ordenar las categorías para iterar de A a K
                categorias_ordenadas = sorted(categorias_venta.keys())

                for cat_letra in categorias_ordenadas:
                    limites = categorias_venta[cat_letra]

                    # Regla de ingresos
                    if ingresos_anuales is not None and ingresos_anuales > limites['ingresos']:
                        continue # Pasa a la siguiente categoría

                    # Pregunta de Superficie
                    res_superficie = preguntar(
                        f"¿La superficie afectada de tu local **supera** los **{limites['superficie']} m2** para la Categoría {cat_letra}?",
                        ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                    )
                    if res_superficie == "SÍ (Supera el límite)":
                        continue # Correcto: pasa a la siguiente categoría

                    # Pregunta de Energía
                    res_energia = preguntar(
                        f"¿El consumo anual de energía eléctrica de tu local **supera** los **{limites['energia']} Kw** para la Categoría {cat_letra}?",
                        ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                    )
                    if res_energia == "SÍ (Supera el límite)":
                        continue # Correcto: pasa a la siguiente categoría

                    # Pregunta de Alquileres
                    res_alquileres = preguntar(
                        f"¿Los alquileres devengados anualmente de tu local **superan** los **${limites['alquileres']:,.2f}** para la Categoría {cat_letra}?",
                        ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                    )
                    if res_alquileres == "SÍ (Supera el límite)":
                        continue # Correcto: pasa a la siguiente categoría

                    # Si llega hasta aquí, significa que el usuario respondió 'NO' a todos los parámetros de esta categoría
                    categoria_final = cat_letra
                    break # Encontramos la categoría, salimos del bucle

                if categoria_final:
                    print(f"\nSegún tus ingresos y los parámetros del local, tu categoría sería la **{categoria_final}**.")
                    res_rel_dependencia = preguntar(
                        "¿Actualmente te encontrás en relación de dependencia?",
                        ["SÍ", "NO"]
                    )
                    if res_rel_dependencia == "SÍ":
                        mostrar_resultado(f"Monotributo Categoría {categoria_final} (Solo Impuesto Integrado: ${pagos_monotributo_venta[categoria_final]['solo_impuesto']:,.2f})")
                    else:
                        mostrar_resultado(f"Monotributo Categoría {categoria_final} (Impuesto Integrado: ${pagos_monotributo_venta[categoria_final]['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_venta[categoria_final]['sipa']:,.2f}, Obra Social: ${pagos_monotributo_venta[categoria_final]['obra_social']:,.2f}, Total: ${pagos_monotributo_venta[categoria_final]['completo']:,.2f})")
                else:
                    mostrar_resultado("Régimen General (No encuadra en Monotributo por límites de local o ingresos, incluso para la categoría más baja).")

            else: # NO tiene local (Venta)
                print("\nDebes evaluar tu categoría solo por límite de ingresos brutos.")
                categoria_encontrada = None
                for cat_letra, limites in categorias_venta.items():
                    if ingresos_anuales is None or ingresos_anuales <= limites['ingresos']:
                        categoria_encontrada = cat_letra
                        break

                if categoria_encontrada:
                    print(f"\nSegún tus ingresos, tu categoría sería la **{categoria_encontrada}**.")
                    res_rel_dependencia = preguntar(
                        "¿Actualmente te encontrás en relación de dependencia?",
                        ["SÍ", "NO"]
                    )
                    if res_rel_dependencia == "SÍ":
                        mostrar_resultado(f"Monotributo Categoría {categoria_encontrada} (Solo Impuesto Integrado: ${pagos_monotributo_venta[categoria_encontrada]['solo_impuesto']:,.2f})")
                    else:
                        mostrar_resultado(f"Monotributo Categoría {categoria_encontrada} (Impuesto Integrado: ${pagos_monotributo_venta[categoria_encontrada]['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_venta[categoria_encontrada]['sipa']:,.2f}, Obra Social: ${pagos_monotributo_venta[categoria_encontrada]['obra_social']:,.2f}, Total: ${pagos_monotributo_venta[categoria_encontrada]['completo']:,.2f})")
                else:
                    mostrar_resultado(
                        "Régimen General (No encuadra en Monotributo por ingresos)")

        else: # No genera ingresos / No puede estimar facturación anual (Venta) - Categoría A Provisoria
            print("\nDado que no generás ingresos o no podés estimar tu facturación, se evaluará la **Categoría A Provisoria**.")
            res_tiene_local_prov_venta = preguntar(
                "¿Tu actividad se desarrolla en un local físico (alquilado o propio)?",
                ["SÍ (Tiene local)", "NO (No tiene local)"]
            )

            if res_tiene_local_prov_venta == "SÍ (Tiene local)":
                # Límites para Categoría A de Venta (que se usan para la inscripción provisoria)
                limites_cat_A_venta = categorias_venta['A']

                # Ahora con las preguntas que usan los límites de Categoría A
                res_superficie_prov = preguntar(
                    f"¿La superficie afectada de tu local **supera** los **{limites_cat_A_venta['superficie']} m2** para la Categoría A?",
                    ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                )
                if res_superficie_prov == "SÍ (Supera el límite)":
                    mostrar_resultado("Régimen General (No encuadra Monotributo provisorio por límite de superficie para Categoría A)")
                    return # Aquí el return está correcto, porque si supera la Categoría A provisoria, es Régimen General.

                res_energia_prov = preguntar(
                    f"¿El consumo anual de energía eléctrica de tu local **supera** los **{limites_cat_A_venta['energia']} Kw** para la Categoría A?",
                    ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                )
                if res_energia_prov == "SÍ (Supera el límite)":
                    mostrar_resultado("Régimen General (No encuadra Monotributo provisorio por límite de energía para Categoría A)")
                    return # Aquí el return está correcto

                res_alquileres_prov = preguntar(
                    f"¿Los alquileres devengados anualmente de tu local **superan** los **${limites_cat_A_venta['alquileres']:,.2f}** para la Categoría A?",
                    ["SÍ (Supera el límite)", "NO (No supera el límite / Desconozco)"]
                )
                if res_alquileres_prov == "SÍ (Supera el límite)":
                    mostrar_resultado("Régimen General (No encuadra Monotributo provisorio por límite de alquileres para Categoría A)")
                    return # Aquí el return está correcto

                # Si llega hasta aquí, cumple con Categoría A con local para inscripción provisoria
                print("\nCumplís con los límites de los parámetros del local para la Categoría A (inscripción provisoria).")
                res_rel_dep_prov = preguntar(
                    "¿Actualmente estás en relación de dependencia?",
                    ["SÍ", "NO"]
                )
                if res_rel_dep_prov == "SÍ":
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Solo Impuesto Integrado: ${pagos_monotributo_venta['A']['solo_impuesto']:,.2f})")
                else:
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Impuesto Integrado: ${pagos_monotributo_venta['A']['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_venta['A']['sipa']:,.2f}, Obra Social: ${pagos_monotributo_venta['A']['obra_social']:,.2f}, Total: ${pagos_monotributo_venta['A']['completo']:,.2f})")
            else: # No tiene local (Venta, A Provisoria)
                print("\nComo no generás ingresos y no tenés local, tu categoría provisoria es la **A**.")
                res_rel_dep_prov = preguntar(
                    "¿Actualmente estás en relación de dependencia?",
                    ["SÍ", "NO"]
                )
                if res_rel_dep_prov == "SÍ":
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Solo Impuesto Integrado: ${pagos_monotributo_venta['A']['solo_impuesto']:,.2f})")
                else:
                    mostrar_resultado(f"Monotributo Categoría **A Provisoria** (Impuesto Integrado: ${pagos_monotributo_venta['A']['solo_impuesto']:,.2f}, SIPA: ${pagos_monotributo_venta['A']['sipa']:,.2f}, Obra Social: ${pagos_monotributo_venta['A']['obra_social']:,.2f}, Total: ${pagos_monotributo_venta['A']['completo']:,.2f})")

# Para ejecutar el sistema:
if __name__ == "__main__":
    sistema_experto_monotributo()

    # uvicorn api:app --reload